"""
Calendar Export Module

WHAT IT DOES:
- Generates iCalendar (.ics) format files from task plans
- Creates calendar events for each task with proper timing and metadata
- Supports task dependencies, priorities, and status tracking
- Compatible with Google Calendar, Outlook, Apple Calendar, and other calendar apps

FORMAT SUPPORT:
- RFC 5545 iCalendar specification
- UTF-8 encoding for international characters
- Proper timezone handling (UTC)
- Event relationships and dependencies

USAGE:
    from calendar_export import generate_icalendar
    ical_content = generate_icalendar(plan_data)
"""

from datetime import datetime, timedelta
from typing import List, Dict, Optional
import re


def generate_icalendar(plan: Dict) -> str:
    """
    Generate iCalendar (.ics) format from plan data
    
    WHAT IT DOES:
    - Creates a complete iCalendar file with all tasks as events
    - Sets proper start/end times based on task deadlines
    - Includes task metadata (priority, status, dependencies)
    - Formats for maximum calendar app compatibility
    
    PARAMETERS:
    - plan: Complete plan data including tasks, goal, and metadata
    
    RETURNS:
    - iCalendar content as string (UTF-8 encoded)
    
    CALENDAR FIELDS:
    - UID: Unique identifier for each event
    - DTSTART/DTEND: Task start and deadline times
    - SUMMARY: Task title
    - DESCRIPTION: Task description
    - PRIORITY: 1 (high), 5 (medium), 9 (low)
    - STATUS: COMPLETED or NEEDS-ACTION
    - RELATED-TO: Task dependencies
    
    EXAMPLE:
    BEGIN:VCALENDAR
    VERSION:2.0
    PRODID:-//TaskFlow//EN
    BEGIN:VEVENT
    UID:0-abc123@smarttaskplanner.com
    DTSTART:20250113T090000Z
    DTEND:20250113T170000Z
    SUMMARY:Design wireframes
    DESCRIPTION:Create low-fidelity sketches...
    END:VEVENT
    END:VCALENDAR
    """
    try:
        # Start building iCalendar content
        ical_lines = []
        
        # Calendar header
        ical_lines.extend([
            "BEGIN:VCALENDAR",
            "VERSION:2.0",
            "PRODID:-//TaskFlow//EN",
            "CALSCALE:GREGORIAN",
            "METHOD:PUBLISH",
            f"X-WR-CALNAME:{_escape_ical_text(plan.get('goal', 'Task Plan'))}",
            "X-WR-TIMEZONE:UTC",
            "X-WR-CALDESC:Generated by TaskFlow"
        ])
        
        # Generate events for each task
        for task in plan.get('tasks', []):
            event_lines = _generate_task_event(task, plan.get('plan_id', ''))
            ical_lines.extend(event_lines)
        
        # Calendar footer
        ical_lines.append("END:VCALENDAR")
        
        # Join with CRLF line endings (RFC 5545 requirement)
        return "\r\n".join(ical_lines)
        
    except Exception as e:
        print(f"ERROR: Failed to generate iCalendar: {e}")
        return _generate_error_calendar(str(e))


def _generate_task_event(task: Dict, plan_id: str) -> List[str]:
    """
    Generate iCalendar event lines for a single task
    
    WHAT IT DOES:
    - Creates proper event timing based on task deadline
    - Calculates start time based on estimated hours
    - Formats all task metadata for calendar compatibility
    - Handles dependencies and relationships
    
    PARAMETERS:
    - task: Individual task data
    - plan_id: Plan identifier for unique event IDs
    
    RETURNS:
    - List of iCalendar event lines
    """
    event_lines = []
    
    try:
        # Calculate event timing
        deadline = _parse_datetime(task.get('deadline'))
        estimated_hours = task.get('estimated_hours', 8)
        
        # Set end time to deadline
        end_time = deadline
        # Set start time to estimated hours before deadline
        start_time = end_time - timedelta(hours=estimated_hours)
        
        # Ensure start time is not in the past
        now = datetime.now()
        if start_time < now:
            start_time = now
            end_time = start_time + timedelta(hours=estimated_hours)
        
        # Format times for iCalendar (UTC)
        start_str = start_time.strftime('%Y%m%dT%H%M%SZ')
        end_str = end_time.strftime('%Y%m%dT%H%M%SZ')
        timestamp_str = datetime.now().strftime('%Y%m%dT%H%M%SZ')
        
        # Generate unique event ID
        event_uid = f"{task.get('id', 0)}-{plan_id}@smarttaskplanner.com"
        
        # Build event lines
        event_lines.extend([
            "BEGIN:VEVENT",
            f"UID:{event_uid}",
            f"DTSTAMP:{timestamp_str}",
            f"DTSTART:{start_str}",
            f"DTEND:{end_str}",
            f"SUMMARY:{_escape_ical_text(task.get('title', 'Untitled Task'))}",
            f"DESCRIPTION:{_escape_ical_text(_format_task_description(task))}",
            f"PRIORITY:{_get_ical_priority(task.get('priority', 'medium'))}",
            f"STATUS:{_get_ical_status(task.get('status', 'todo'))}",
            f"CATEGORIES:{_escape_ical_text(task.get('priority', 'medium').upper())}",
            f"X-TASK-ID:{task.get('id', 0)}",
            f"X-ESTIMATED-HOURS:{estimated_hours}",
        ])
        
        # Add location if available
        if task.get('location'):
            event_lines.append(f"LOCATION:{_escape_ical_text(task.get('location'))}")
        
        # Add notes if available
        if task.get('notes'):
            event_lines.append(f"X-NOTES:{_escape_ical_text(task.get('notes'))}")
        
        # Add completion timestamp if task is completed
        if task.get('completed_at'):
            completed_time = _parse_datetime(task.get('completed_at'))
            event_lines.append(f"COMPLETED:{completed_time.strftime('%Y%m%dT%H%M%SZ')}")
        
        # Add dependencies as related events
        dependencies = task.get('dependencies', [])
        if dependencies:
            for dep_id in dependencies:
                dep_uid = f"{dep_id}-{plan_id}@smarttaskplanner.com"
                event_lines.append(f"RELATED-TO:{dep_uid}")
        
        # Add recurrence if task is recurring (future feature)
        if task.get('recurring'):
            event_lines.append(f"RRULE:{task.get('recurring')}")
        
        event_lines.append("END:VEVENT")
        
    except Exception as e:
        print(f"ERROR: Failed to generate event for task {task.get('id', 'unknown')}: {e}")
        # Generate minimal event on error
        event_lines = [
            "BEGIN:VEVENT",
            f"UID:{task.get('id', 0)}-{plan_id}@smarttaskplanner.com",
            f"DTSTAMP:{datetime.now().strftime('%Y%m%dT%H%M%SZ')}",
            f"DTSTART:{datetime.now().strftime('%Y%m%dT%H%M%SZ')}",
            f"DTEND:{(datetime.now() + timedelta(hours=1)).strftime('%Y%m%dT%H%M%SZ')}",
            f"SUMMARY:{_escape_ical_text(task.get('title', 'Task Error'))}",
            "DESCRIPTION:Error generating task details",
            "END:VEVENT"
        ]
    
    return event_lines


def _parse_datetime(date_str: Optional[str]) -> datetime:
    """
    Parse datetime string with fallback handling
    
    WHAT IT DOES:
    - Handles various datetime formats from the database
    - Provides sensible defaults for missing dates
    - Ensures UTC timezone handling
    
    PARAMETERS:
    - date_str: Datetime string (ISO format preferred)
    
    RETURNS:
    - Parsed datetime object in UTC
    """
    if not date_str:
        return datetime.now()
    
    try:
        # Try ISO format first
        if 'T' in date_str:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        
        # Try date only format
        if '-' in date_str and len(date_str) == 10:
            return datetime.strptime(date_str, '%Y-%m-%d')
        
        # Try other common formats
        for fmt in ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%m/%d/%Y']:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        
        # Fallback to current time
        return datetime.now()
        
    except Exception:
        return datetime.now()


def _escape_ical_text(text: str) -> str:
    """
    Escape text for iCalendar format
    
    WHAT IT DOES:
    - Escapes special characters per RFC 5545
    - Handles line breaks and special characters
    - Ensures proper encoding
    
    PARAMETERS:
    - text: Raw text to escape
    
    RETURNS:
    - Properly escaped iCalendar text
    """
    if not text:
        return ""
    
    # Escape special characters
    text = text.replace('\\', '\\\\')
    text = text.replace(',', '\\,')
    text = text.replace(';', '\\;')
    text = text.replace('\n', '\\n')
    text = text.replace('\r', '')
    
    # Limit line length (RFC 5545 requirement)
    if len(text) > 75:
        # Fold long lines
        lines = []
        while len(text) > 75:
            lines.append(text[:75])
            text = " " + text[75:]  # Space for folding
        lines.append(text)
        text = '\r\n'.join(lines)
    
    return text


def _format_task_description(task: Dict) -> str:
    """
    Format task data into a readable description
    
    WHAT IT DOES:
    - Combines task description with metadata
    - Includes priority, estimated hours, and status
    - Formats dependencies and notes
    
    PARAMETERS:
    - task: Task data dictionary
    
    RETURNS:
    - Formatted description string
    """
    parts = []
    
    # Main description
    if task.get('description'):
        parts.append(task['description'])
    
    # Metadata
    metadata = []
    if task.get('priority'):
        metadata.append(f"Priority: {task['priority'].upper()}")
    if task.get('estimated_hours'):
        metadata.append(f"Estimated: {task['estimated_hours']} hours")
    if task.get('status'):
        metadata.append(f"Status: {task['status'].upper()}")
    
    if metadata:
        parts.append("\n" + " | ".join(metadata))
    
    # Dependencies
    dependencies = task.get('dependencies', [])
    if dependencies:
        parts.append(f"\nDepends on tasks: {', '.join(map(str, dependencies))}")
    
    # Notes
    if task.get('notes'):
        parts.append(f"\nNotes: {task['notes']}")
    
    return '\n'.join(parts)


def _get_ical_priority(priority: str) -> str:
    """
    Convert task priority to iCalendar priority value
    
    WHAT IT DOES:
    - Maps high/medium/low to iCalendar numeric priorities
    - Uses standard iCalendar priority scale (1-9)
    
    PARAMETERS:
    - priority: Task priority string
    
    RETURNS:
    - iCalendar priority string
    """
    priority_map = {
        'high': '1',
        'medium': '5', 
        'low': '9'
    }
    return priority_map.get(priority.lower(), '5')


def _get_ical_status(status: str) -> str:
    """
    Convert task status to iCalendar status
    
    WHAT IT DOES:
    - Maps task status to iCalendar event status
    - Handles various status values
    
    PARAMETERS:
    - status: Task status string
    
    RETURNS:
    - iCalendar status string
    """
    status_map = {
        'completed': 'COMPLETED',
        'in_progress': 'IN-PROCESS',
        'todo': 'NEEDS-ACTION',
        'blocked': 'NEEDS-ACTION'
    }
    return status_map.get(status.lower(), 'NEEDS-ACTION')


def _generate_error_calendar(error_message: str) -> str:
    """
    Generate a minimal error calendar when generation fails
    
    WHAT IT DOES:
    - Creates a basic calendar with error information
    - Ensures valid iCalendar format even on failure
    - Provides user feedback about the error
    
    PARAMETERS:
    - error_message: Error description
    
    RETURNS:
    - Minimal iCalendar content
    """
    now = datetime.now()
    timestamp = now.strftime('%Y%m%dT%H%M%SZ')
    
    return "\r\n".join([
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//TaskFlow//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:PUBLISH",
        "X-WR-CALNAME:Task Plan Export Error",
        "X-WR-TIMEZONE:UTC",
        "BEGIN:VEVENT",
        f"UID:error-{timestamp}@smarttaskplanner.com",
        f"DTSTAMP:{timestamp}",
        f"DTSTART:{timestamp}",
        f"DTEND:{(now + timedelta(hours=1)).strftime('%Y%m%dT%H%M%SZ')}",
        "SUMMARY:Export Error",
        f"DESCRIPTION:Failed to generate calendar: {_escape_ical_text(error_message)}",
        "STATUS:NEEDS-ACTION",
        "END:VEVENT",
        "END:VCALENDAR"
    ])


# ============================================================================
# TESTING - Run this file directly to test calendar generation
# ============================================================================

if __name__ == "__main__":
    """
    Test function - Runs when you execute: python calendar_export.py
    
    WHAT IT DOES:
    1. Creates a sample task plan
    2. Generates iCalendar content
    3. Saves to test file
    4. Displays success message
    """
    
    # Sample test data
    test_plan = {
        "plan_id": "test-123",
        "goal": "Test Task Plan",
        "tasks": [
            {
                "id": 0,
                "title": "Design wireframes",
                "description": "Create low-fidelity sketches of key pages",
                "priority": "high",
                "estimated_hours": 4,
                "deadline": "2025-01-15T17:00:00Z",
                "status": "todo",
                "dependencies": []
            },
            {
                "id": 1,
                "title": "Implement authentication",
                "description": "Set up user login and registration",
                "priority": "medium",
                "estimated_hours": 8,
                "deadline": "2025-01-20T17:00:00Z",
                "status": "todo",
                "dependencies": [0],
                "notes": "Use JWT tokens"
            }
        ]
    }
    
    try:
        # Generate calendar
        ical_content = generate_icalendar(test_plan)
        
        # Save to file
        with open("test_calendar.ics", "w", encoding="utf-8") as f:
            f.write(ical_content)
        
        print("SUCCESS: Calendar generated successfully!")
        print("File saved as: test_calendar.ics")
        print("You can import this into Google Calendar, Outlook, or Apple Calendar")
        print(f"Content length: {len(ical_content)} characters")
        
    except Exception as e:
        print(f"ERROR: Failed to generate test calendar: {e}")
